The most important step in defending against broken access control is ensuring that a user's role is accurately enforced by the server, 
regardless of any client-side validation. Server-side validation is critical because it guarantees that even if a user bypasses client-side security, 
they can only perform actions valid for their role.

To achieve this, the system first authenticates the user and generates a token or session that represents the user's identity. 
This token typically includes the user's roles and permissions and has an expiration time, requiring the user to log in again once it expires.

Once the server generates the token, it signs it using a private key. This signature ensures the token's integrity and authenticity, 
meaning it was issued by the server and has not been tampered with. If a user attempts to modify the token, such as altering their role, 
the token's signature will no longer match the server's signature, making it invalid.

By only accepting valid, signed tokens generated by the server, the system can ensure that users are performing only those actions that they are authorized to do.

Explaining JWT Signatures:
A JSON Web Token (JWT) consists of three parts: Header, Payload, and Signature.

The Header contains metadata about the token and the algorithm used for signing.
The Payload includes the claims, such as user ID, roles, permissions, and expiration time.
The Signature is created by hashing the header and payload together using the server's private key.

If a user attempts to modify the token (for example, changing the payload to elevate their role), they would need to generate a new signature for the modified token. 
When the token is sent back to the server, the server will generate its own signature using the header and payload and compare it to the signature provided by the user. 
The signature geneated by the server uses the SHA-256 hashing algorithm and the servers private key, something the user will not have. 
When the signature generated by the sever does not match the token sent by the user, it will reject the token and return a 401 Unauthorized or 403 Forbidden response.

Due to the strength of the SHA-256 algorithm used in JWTs, it is computationally infeasible for an attacker to reverse-engineer the private key from the signature. 
Even if a hacker has access to the payload, header, signature and hashing algorithm they cannot determine the private key.
Therefore a malicious user cannot generate a valid signature for the modified data.